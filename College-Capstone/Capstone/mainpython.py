import os
import json
from python_lexer import PythonLexer
from python_parser import PythonParser
from python_semantic_analyzer import PythonSemanticAnalyzer
from python_to_cpp_converter import PythonToCppConverter
from geminiAPI import add_ai_comments


# Processes a source file and converts it to the target language
def process_file(file_path, source_language, target_language, verbose=False):
    print(f"Process file called with:\n- file_path: {file_path}\n- source_language: {source_language}\n- target_language: {target_language}")
   
    if file_path is None:
        raise ValueError("File path cannot be None.")
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"The file {file_path} does not exist.")

    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            contents = file.read()
        
        if verbose:
            print(f"Reading file: {file_path}")
            print(f"Content being tokenized:\n{contents[:100]}{'...' if len(contents) > 100 else ''}")

        if source_language == 'python' and target_language == 'c++':
            lexer = PythonLexer()
            tokens = lexer.tokenize(contents)
            if verbose:
                print("Tokens generated by lexer:")
                for token in tokens:
                    print(token)

            parser = PythonParser(tokens)
            ast = parser.parse_program()
            if verbose:
                print("\nRunning parser...")
                print("\nAbstract Syntax Tree (AST):")
                print(json.dumps(ast, indent=4))

            semantic_analyzer = PythonSemanticAnalyzer()
            errors = semantic_analyzer.analyze(ast)
            if verbose:
                print("\nRunning semantic analyzer...")
                if errors:
                    print("\nSemantic Errors:")
                    for error in errors:
                        print(error)
                else:
                    print("\nSemantic analysis completed without errors.")

            converter = PythonToCppConverter(ast)
            converted_code = converter.generate_code()
            if verbose:
                print(f"\nRunning code converter... Type of converted_code: {type(converted_code)}")
                print("Generated C++ Code:\n", converted_code)

            # Optionally add AI-generated comments
            final_code = converted_code
            if verbose:
                print("\nSending code to Gemini for commenting...")
            try:
                commented_code = add_ai_comments(converted_code, target_language)
                if commented_code is not None:
                    final_code = commented_code
                if verbose:
                    print(f"Commented code type: {type(final_code)}")
                    print("Commented C++ Code:\n", final_code)
            except Exception as ai_error:
                if verbose:
                    print(f"Error in AI commenting: {ai_error}")
               

            if not final_code:
                if verbose:
                    print("Final code is empty or None; conversion or commenting failed.")
                raise ValueError("Final code is empty or None")

            if verbose:
                print("\nFinal Converted Code:")
                print(final_code)

            return final_code  

        else:
            raise ValueError(f"Unsupported conversion from {source_language} to {target_language}")

    except FileNotFoundError as e:
        if verbose:
            print(f"File not found: {e}")
        raise
    except IOError as e:
        if verbose:
            print(f"I/O error occurred: {e}")
        raise
    except Exception as e:
        if verbose:
            print(f"An unexpected error occurred: {e}")
        raise

if __name__ == "__main__":
    file_folder = os.path.dirname(os.path.abspath(__file__))
    file_path = os.path.join(file_folder, "test.py")
    try:
        result = process_file(file_path, 'python', 'c++', verbose=True)
        if result is None:
            print("Conversion process failed.")
        else:
            print(f"Conversion completed. Output:\n{result}")
    except Exception as e:
        print(f"Error: {e}")