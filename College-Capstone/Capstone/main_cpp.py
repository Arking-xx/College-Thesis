import os
import json
from lexercpp import Lexer, TOKEN_TYPES
from parsercpp import Parser
from semantic_analyzer_cpp import SemanticAnalyzer
from convertercpp import Converter
from geminiAPI import add_ai_comments

# Converts source code from one language to another and adds AI-generated comments
def process_file(file_path, source_language, target_language, verbose=False, add_comments=True):
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"The file {file_path} does not exist.")
    keywords = {
        'c++': ['int', 'float', 'double', 'bool', 'if', 'else', 'for', 'while', 'return', 'void', 'using', 'namespace', 'include', 'string']
    }.get(source_language, [])
    try:
        if verbose:
            print(f"Reading file: {file_path}")
        with open(file_path, 'r') as file:
            contents = file.read()
        if verbose:
            print("File contents read successfully.")
        if verbose:
            print("Running lexer...")
        lexer = Lexer(TOKEN_TYPES, keywords)
        tokens = lexer.tokenize(contents)
        if verbose:
            print("Tokens generated by lexer:")
            for token in tokens:
                print(token)
        if verbose:
            print("\nRunning parser...")
        parser = Parser(tokens)
        ast = parser.parse_program()
        json_ast = json.dumps(ast, indent=4)
        data = json.loads(json_ast)
        if verbose:
            print("\nAbstract Syntax Tree (AST):")
            print(json_ast)
        if verbose:
            print("\nRunning semantic analyzer...")
        semantic_analyzer = SemanticAnalyzer()
        errors = semantic_analyzer.analyze(ast)
        if errors:
            if verbose:
                print("\nSemantic Errors:")
                for error in errors:
                    print(error)
            raise ValueError("Semantic errors detected. Conversion aborted.")
        else:
            if verbose:
                print("\nSemantic analysis completed without errors.")
        if verbose:
            print("\nRunning code converter...")
        converter = Converter(data)
        converted_code = converter.generate_code()
        
        # Decide whether to add comments
        final_code = converted_code
        if add_comments:
            if verbose:
                print("\nSending code to Gemini for commenting...")
            final_code = add_ai_comments(converted_code, target_language)

        if verbose:
            print(f"\n{'Commented' if add_comments else 'Converted'} Code:")
            print(final_code)
        return final_code  # Return the code string instead of a file path
    except FileNotFoundError as e:
        raise FileNotFoundError(f"Error: {e}")
    except UnicodeDecodeError:
        raise UnicodeDecodeError("Error: The file contains invalid characters.")
    except SyntaxError as e:
        raise SyntaxError(f"Syntax Error: {e}")
    except ValueError as e:
        raise ValueError(f"Value Error: {e}")
    except NameError as e:
        raise NameError(f"Name Error: {e}. Ensure all required modules and classes are imported.")
    except AttributeError as e:
        raise AttributeError(f"Attribute Error: {e}. Ensure all methods and attributes are correctly defined.")
    except Exception as e:
        raise Exception(f"An unexpected error occurred: {e}")

# Entry point for running the file conversion process
if __name__ == "__main__":
    file_folder = os.path.dirname(__file__)
    file_path = os.path.join(file_folder, "test.txt")
    source_language = 'c++'
    target_language = 'python'
    try:
        converted_code = process_file(file_path, source_language, target_language, verbose=True, add_comments=False)  # Get code string
        print(f"Conversion completed. Output:\n{converted_code}")
    except Exception as e:
        print(e)